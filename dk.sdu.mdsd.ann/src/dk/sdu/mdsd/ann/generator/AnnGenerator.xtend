/*
 * generated by Xtext 2.11.0
 */
package dk.sdu.mdsd.ann.generator

import org.eclipse.xtext.xbase.lib.Exceptions.*
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import dk.sdu.mdsd.ann.ann.ANNModel
import dk.sdu.mdsd.ann.ann.Hidden
import dk.sdu.mdsd.ann.ann.Input
import dk.sdu.mdsd.ann.ann.Output
import dk.sdu.mdsd.ann.ann.Custom
import dk.sdu.mdsd.ann.ann.NumberLiteral
import dk.sdu.mdsd.ann.ann.Letter
import dk.sdu.mdsd.ann.ann.Fac
import dk.sdu.mdsd.ann.ann.Part
import dk.sdu.mdsd.ann.ann.Euler
import dk.sdu.mdsd.ann.ann.NLog
import dk.sdu.mdsd.ann.ann.Sin
import dk.sdu.mdsd.ann.ann.Cos
import dk.sdu.mdsd.ann.ann.Power
import dk.sdu.mdsd.ann.ann.Sqrt
import dk.sdu.mdsd.ann.ann.External

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class AnnGenerator extends AbstractGenerator {
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		resource.allContents.filter(typeof(ANNModel)).forEach[generateANNFile(fsa, resource)]
		resource.allContents.filter(typeof(Custom)).forEach[generateCustomFunctionFile(fsa, resource)]
	}
	
	
	def generateANNFile(ANNModel m, IFileSystemAccess2 access2, Resource resource) {
		access2.generateFile(m.name+".java", m.generateNetwork)
		access2.generateFile("transfers/ITransferFactory.java",m.generateITransferFactory(resource))
	}
	
	def generateCustomFunctionFile(Custom c, IFileSystemAccess2 access2, Resource resource) {
		access2.generateFile("transfers/"+c.name + ".java", c.generateCustomFunction)
	}
	
	def CharSequence generateITransferFactory(ANNModel model, Resource resource) '''
	package transfers;
	public interface ITransferFactory {
		«FOR l: model.layer»
		«if(l instanceof Hidden){
			if(l.l_rule instanceof External) {
				(l.l_rule as External).generateGetLineForITransferFactory
			}
		}»
		«ENDFOR»
	}
	'''
	
	def CharSequence generateGetLineForITransferFactory(External ext) '''
		ITransfer get«ext.name.toFirstUpper»();
	'''
	
	def CharSequence generateNetwork(ANNModel model) '''
	import java.util.*;
	import transfers.*;
	import ann.*; 


	public class «model.name» {
		private double alpha = «model.alpha»;
		private int epochs = «model.epochs»;
		private ArrayList<Integer> layers;
		private ArrayList<ITransfer> transfers;
		private ANN ann;
		
		public «model.name»(ITransferFactory factory) {
			layers = new ArrayList<>();
			transfers = new ArrayList<>();
			init(factory);
			run();
		}
		
		public Integer[] getLayers() {
			return this.layers.toArray(new Integer[this.transfers.size()]);
		}
		
		public ArrayList<ITransfer> getTransfers() {
			return this.transfers;
		}
	
		public void addLayerWithTransfer(int size, ITransfer transfer) {
			if(transfer == null) {
				this.layers.add(size);
			} else {
				this.layers.add(size);
				this.transfers.add(transfer);
			}
		}
		
		public double getAlpha() {
			return this.alpha;
		}
		
		public void setAlpha(double alpha) {
			this.alpha = alpha;
		}
		
		public int getEpochs() {
			return this.epochs;
		}
		
		public void setEpochs(int epochs) {
			this.epochs = epochs;
		}
		
		private void init(ITransferFactory factory) {
			«FOR l: model.layer»
			«l.generateLayer»
			«ENDFOR»
			
			ArrayList<double[]> inputs = new ArrayList<>();
			        inputs.add(new double[]{0,1});
			        inputs.add(new double[]{0,1});
			        inputs.add(new double[]{1,0});
			        inputs.add(new double[]{1,0});
			        int[] y = new int[]{0,0,1,1};
			        
			this.ann = new ANN(getLayers(),getTransfers(),getAlpha(),getEpochs(),inputs,y);
		}
		
		private void run(){
			this.ann.run();
		}
		
		
		public static void main (String[] args){
			Network n = new Network(null);
			
			}
		
	}
	'''
	
	def CharSequence generateCustomFunction(Custom customFunction) '''
	package transfers;
	public class «customFunction.name» implements ITransfer {
		
		public double transfer(double «customFunction.input.value») {
			return «customFunction.generateCustomExp(customFunction.input.value)»
		}
		public double derivative(double «customFunction.input.value») {
			return «customFunction.generateCustomDer(customFunction.input.value)»
		}
	}
	'''
	
	def generateCustomExp(Custom custom, String name) '''
		«custom.exp.generateExp(name)»;
	'''
	
	def generateCustomDer(Custom custom, String name) '''
		«custom.der.generateExp(name)»;
	'''
		
	def dispatch CharSequence generateExp(Part exp, String name) '''(«exp.left.generateExp(name)»«exp.operator»«exp.right.generateExp(name)»)'''
	
	def dispatch CharSequence generateExp(Fac exp, String name) '''(«exp.left.generateExp(name)»«exp.operator»«exp.right.generateExp(name)»)'''
	
	def dispatch CharSequence generateExp(NumberLiteral exp, String name) '''«exp.operator»«exp.value»'''
	
	def dispatch CharSequence generateExp(Euler exp, String name) '''Math.exp(«exp.value.generateExp(name)»)'''
	
	def dispatch CharSequence generateExp(NLog exp, String name) '''Math.log(«exp.value.generateExp(name)»)'''
	
	def dispatch CharSequence generateExp(Sin exp, String name) '''Math.sin(«exp.value.generateExp(name)»)'''
	
	def dispatch CharSequence generateExp(Cos exp, String name) '''Math.cos(«exp.value.generateExp(name)»)'''
	
	def dispatch CharSequence generateExp(Sqrt exp, String name) '''Math.cos(«exp.value.generateExp(name)»)'''
	
	def dispatch CharSequence generateExp(Power exp, String name) '''Math.pow(«exp.base.generateExp(name)», «exp.exponent.generateExp(name)»)'''
	
	def dispatch CharSequence generateExp(Letter exp, String name) '''
		«exp.operator»«IF exp.value==name»«exp.value»«ENDIF»
		«IF exp.value!=name»
			/** Autocorrected due to difference in names */«name»
		«ENDIF»
		'''
	
	def dispatch generateLayer(Hidden layer) '''
	«IF layer.l_rule.sigmoid»
	addLayerWithTransfer(«layer.size», new Sigmoid());
	«ENDIF»
	«IF layer.l_rule.tansig»
	addLayerWithTransfer(«layer.size», new Tansig());
	«ENDIF»
	«IF layer.l_rule.namedFunction!=null»
	addLayerWithTransfer(«layer.size», «layer.l_rule.namedFunction.generateRule»);
	«ENDIF»
	'''
	
	def dispatch generateLayer(Input layer) '''
		addLayerWithTransfer(«layer.size», null);
	'''
		
	def dispatch generateLayer(Output layer) '''
		«IF layer.l_rule.sigmoid»
		addLayerWithTransfer(«layer.size», new Sigmoid());
		«ENDIF»
		«IF layer.l_rule.tansig»
		addLayerWithTransfer(«layer.size», new Tansig());
		«ENDIF»
		«IF layer.l_rule.namedFunction!=null»
		addLayerWithTransfer(«layer.size», «layer.l_rule.namedFunction.generateRule»);
		«ENDIF»
	'''
	
	
	def dispatch generateRule(External rule)'''factory.get«rule.name.toFirstUpper»()''' 
		
	
	def dispatch generateRule(Custom rule)'''new «rule.name»()'''
	
	
}